####1.分布式幂等

- 查询不需要幂等，删除的幂等比较简单，第一次删除，后续发现删除，
直接返回成功
  
- 唯一索引和主键索引保证新增数据唯一
- 锁相关 分布式锁 乐观锁

修改数据时务必上锁或者使用版本号验证，就可以保证幂等。

一定时间范围的热数据内的操作记录做内存bitmap去重。

数据提交前要向服务的申请token，token放到redis或jvm内存，设置token有效时间，提交后后台
校验token，同时删除token，生成新的token返回。token特点：要申请，一次有效性，可以限流。

####2.CAP理论

一致性，可用性，分区容错性只能保证两个，分布式系统必然保证分区容错性，所以大部分系统
只能在一致性和可用性中做权衡。

衍生出BASE理论，保证系统基本可用和最终一致性

####3.分布式解决模型

- 两段式提交：master向所有参与者发送事务信号，所有参与者执行事务后先不提交，返回ack
给master，如果失败或超时，那么发送rollback给所有参与者进行回滚，所有参与者返回成功，
  则通知所有参与者可以提交事务。
  
大量的同步阻塞或故障导致系统的不可用，强一致性牺牲可用性。

- 三段式提交：CanCommit -> yes -> PreCommit -> yes -> DoCommit -> Commited

与两段式相比降低了阻塞范围，依然有不可用情况和不一致性，当在参与者收到 preCommit 请求后等待 do commite 指令时，
此时如果协调者请求中断事务，而协调者无法与参与者正常通信，会导致参与者继续提交事务，造
成数据不一致。

- TCC补偿事务：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。

Try 阶段主要是对业务系统做检测及资源预留。

Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默
认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。

Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。

TCC 的 Try、Confirm 和 Cancel 操作功能要按具体业务来实现，业务耦合度较高，提高了开
发成本。

####4.分布式ID

- UUID：本地生成，生成简单，性能好，没有高可用风险。长度过长，存储冗余，且无序不可读，查询效率低

- 数据库自增ID：数据库生成的ID绝对有序，高可用实现方式简单。需要独立部署数据库实例，成本高，有性能瓶颈

- Redis生成ID：不依赖于数据库，灵活方便，且性能优于数据库；数字ID天然排序，对分页或者需要排
  序的结果很有帮助。如果系统中没有Redis，还需要引入新的组件，增加系统复杂度；需要编码和配置的工作
  量比较大。

- 雪花算法：64位 时间戳 + 机器id + 序列号

####5.限流算法

比如web服务、对外API，这种类型的服务有以下几种可能导致机器被拖垮：
用户增长过快，因为某个热点事件（微博热搜），竞争对象爬虫，恶意接口冲击。

- 计数器算法固定窗口：使用计数器在周期内累加访问次数，当达到设定的限流值时，触发限流策略。下一个
  周期开始时，进行清零，重新计数。

使用redis的incr原子自增性和线程安全即可轻松实现。但是会有严重的临界问题。

- 滑动窗口算法：滑动窗口算法是将时间周期分为N个小周期，分别记录每个小周期内访问次数，并且根据时间滑动
  删除过期的小周期。

当滑动窗口的格子划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精
确。 此算法可以很好的解决固定窗口算法的临界问题。

- 漏桶算法：访问请求到达时直接放入漏桶，如当前容量已达到上限（限流值），则进行丢弃（触发
  限流策略）。漏桶以固定的速率进行释放访问请求（即请求通过），直到漏桶为空。
  
强行控制速度，一般无法应对短时间的突发流量。

- 令牌桶算法：令牌桶算法是程序以某种速度向令牌桶中增加令牌，直到令牌桶满，请求到
  达时向令牌桶请求令牌，如获取到令牌则通过请求，否则触发限流策略。

漏桶算法的改进，限制调用的平均速率的同时还允许一定程度的突发调用。