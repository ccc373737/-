### 1.缓存穿透

即查询一个数据库一定不存在的数据，相当大量访问没有命中缓存，而随后去请求数据层，数据的压力巨大，就形成的穿透现象

- 缓存空对象：即访问一个不存在数据后，将这个返回的空对象也保存起来，同时给一个短的过期时间，这种方法有效过滤了大量不存在的数据请求

- 布隆过滤器：所有可能的访问的key组成一个布隆过滤器。，当请求到来时，先使用布隆过滤器，如果发现不在集合中，就直接返回，而不去做数据层的访问。，

### 2.缓存雪崩

指大量缓存在同一时间失效或者干脆缓存服务出错，导致所有的请求到达数据层，导致数据库也有可能挂掉

- 限流降级：当缓存失效后，通过加锁或者队列的方式来控制读数据的线程数量，比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。

- 过期时间错位：对于某一部分热点key，可以设置不同的过期时间，或者长时间不过期，防止缓存的同时失效。

### 3.关于热点key

某些大促活动或突发性事件，会导致某些key的访问量超过服务器的上线，导致缓存被击穿。

#### 如何获得热点key

- 通过业务调研，活动的预判获得热点key
- 客户端可以统计抓取key，不过这种形式代码侵入性比较高
- proxy层统计，tair集群模式的架构有一个代理层，通过修改代理层获取统计
- redis server自带的monitor指令可以统计，不过会降低redis的性能，而且统计集群需要统计所有的机器
- hotkeys选项获取key的访问频率，LFU简单来讲就是用0-255来表示key的访问频率，值越大说明访问频率越高，并且这里对频率的计数采用的是基于对数的概率增长，LFU为255可以代表100W次的访问。
- 服务器方面可以统计QPS流量来获取某个机器某段事件内明显异常的key
---
#### 如何分散热点key

- 服务端二级缓存：使用ehchahe或本地map，将热点key加载入JVM，加载路径变为

本地缓存 -> redis ->DB

当检测到热点key之后，使用一些方法如mq通知到业务系统，或者放在zk这样的中间件上，当监听到节点变化时，就向本地缓存写入数据。

- 备份热点key：将检测到的key分散到集群中，比如key + random(5)作为新的key可以分散到5个节点中，访问时也随机读取不同的节点中数据
