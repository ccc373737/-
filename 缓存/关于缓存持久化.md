redis的一大优势是支持持久化，保证数据落地，提供更高的可靠性

### 1. 快照持久化RBD

Redis可以备份存储在内存里面的数据在某个时间点上的副本，就像拍照一样保存当前情况到硬盘，文件为二进制dump.rdb

快照持久化是默认的策略，其配置形式如下

```
save 60 10 即60秒内数据有10次修改时触发redis的bgsave过程
```

- bgsave指令：redis会fork一个子进程，持久化存储过程由子进程完成，而父进程可以继续处理请求，阻塞只发生在fork阶段

- save指令：save指令会直接去创建快照，而在创建快照过程中始终被阻塞，即整个持久化过程redis处于不可用的状态。只有在没有没有足够内存去执行bgsave，才会去使用这个指令

---
RBD的优势：
 - 文件紧凑，文件本身即是数据，适合备份和全量复制
 - RBD的快照是由子进程完成，主进程没有多余的IO操作
 - redis如果奔溃重启加载RBD的快照远高于AOF
 
 RBD的劣势：
 - 无法做到实时持久化/秒级持久化
 - fork操作属于对于操作系统而言属于重量级操作，并且fork过程阻塞，这个时间内的数据会丢失
 
### 2. AOF持久化

通过appendonly yes参数开启

AOF的持久化开启后会记录每一次操作记录，追加到appendonly.aof日志后，类似与mysql的binlog。重启时会执行所有记录的命令来恢复数据。

````
AOF同步方式

appendfsync always #每次有数据修改发生就会写入日志中，会严重降低redis的性能
appendfsync everysec #每秒钟同步一次，redis的性能几乎不受影响，最后会丢失1s内的数据
appendfsync no #服务器不负责写入AOF，交由操作系统完成，会丢失不定量的数据，一般不使用
````

AOF的重写rewrite机制，AOF最大的问题是日志文件随着命令的执行会变得过于庞大，而这其中会产生大量的无效命令，如
````
set key "aa"
set key "bb"
set key "cc"
set key "dd"
````
对于存放的数据而言只有最后一个指令是有意义的，前三个都被覆盖了。使用rewrite可以显著压缩文件的大小。与RBD类似，rewrite机制也可以使用bgsave命令fork子进程去完成压缩过程。

---
AOF的优势：
- 追加日志的模式，速度快
- 实时性强，数据几乎不丢失
- AOF日志可以一定程度反应数据存放的趋势，有可读性

AOF的劣势：
- 即使使用rewrite压缩，文件依然可能庞大
- 在恢复和同步数据时慢

### 3. 混合持久化

redis4.0之后，通过配置aof-use-rdb-preamble可以开启混合持久化。

混合持久化模式下，在rewrite过程中会直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 rdb 和 aof 的优点, 在恢复数据中会先恢复rbd的内容，而两次rewrite过程中放入的数据用aof恢复，同时也避免丢失过多的数据。当然缺点也是有的， aof 里面的 rdb 部分就是压缩格式不再是 aof 格式，可读性差。

### 4. 集群模式策略

在集群模式下，可以关闭master的持久化达到最高性能，而slave开启混合模式，并每天做数据备份。