假设有一个支付场景，A服务-100元，发送消费给B，B服务收到消息后+100元，
这里的业务中对于发送消息会出现两种不同的异常

1. 本地事务执行成功，消息发送失败
2. 消息发送成功，本地事务执行失败

所谓事务消息就是保证本地事务和发送消息的一致性。

RMQ中使用办事务消息+事务确认（HalfMsg+commit/rollback）作为解决方案。

1. A向mq发送-100的半事务消息，这条消息落地到commitlog之后，返回成功ack。同时这条消息并不马上进去consumerQueue，对消费端不可见。

2. A收到回执后，执行本地事务，并检查事务状态

3. 将事务状态发送至mq，如果状态为成功，mq则放开消息，消息真正对consumer可见，可以被消费，
如果为失败，则将消息作废

上述过程中，如果1发送消息失败，那么终结事务，如果3中发送事务状态的过程失败，那么由于mq已经接受到一个半事务消息，那么也会定时向服务A请求本地事务执行状态，从而确认消息的状态。
这里的最坏情况就是A与mq完成断开，导致mq始终无法获得A的本地事务状态，那么这条事务消息也不会丢失，随后进入死信通知人工干预。

***
整个半事务执行思路可以升级抽象为一种事务SOA服务。

预备prepare，commit，rollback，事务的定时检查，消息可以组成一个事务管理器。

1. A发送事务，调用prepare方法，同步返回sendResult，得到分布式事务ID

2. A执行本地事务，写入transaction表，成功后将这个ID的事务状态设置为完成

3. A调用SOA服务通知事务状态，SOA服务收到后发送同步消息给B

4. B收到消息后执行对应的本地事务。