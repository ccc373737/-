####1.String 

- String a = new String("aa")
创建了两个对象new String创建一个对象，"aa"创建一个对象，随后上一个对象指向aa。
String对象都是放在元数据区的常量池，有缓存功能，尽量不适用String作为锁对象
  
- String hachcode以31为权值，取每位字符的asc码进行运算，31是一个奇质数，所以31*i=32*i-i=(i<<5)-i，这种位移与减法结合的计算相比一般的运算快很多。



####2.移位运算

基本运算底层都是移位运算，移位运算需要2个机器指令周期，一般运算需要4个机器周期。

####3.类卸载

前三类加载器bootstrap，extendsion，application类加载器加载的类不会被卸载，只有自定义加载器加载的类
可能会被卸载。

要想卸载类必须先卸载该类的加载器。当一个类的类记载器和类的实例都结束时，这个类的生命周期才结束。

有一种情况，就是类加载器被卸载掉了，但是类还没有被卸载掉，这个时候如果有需要用这个类，就可以重新使用不需要加载，方法区的二进制数据结构也是原来的。如果类已经被卸载了，就需要重新加载这个类，当然方法区中的数据结构以及类信息都是重新加载的。

####4.GC

- 1.8之后改为永久代改为元空间，元空间一般不需要指定大小，直接和内存大小挂钩。
但当内存快满时，依然会触发元空间gc，另一种情况当某个类加载器不在存活，也会将对于的内存回收，即类数据取决于类加载的存活时间。

- GCROOT：用于可达性算法判断对象是否需要回收，必要是存活使用的对象，一般可以是静态类型对象，常量池对象，java方法或本地方法栈帧引用的对象。

- finalize：在某一对象判定死亡时调用的方法，但不保证执行，因为gc回收如果速度较快，该方法是来不及执行的。


####5.java对象大小

java空对象占8个字节，引用指针占4个字节，由于是8的倍数，占16个字节

数组对象占24个字节，因为要额外记录长度。

####6.OOM
- 堆heap溢出，可以对堆做dump快照分析，内存泄露可以分析GCRoots引用链，
内存溢出可以检测虚拟机参数-xmx -xms
  
- Java栈和本地栈溢出，SOF，递归深度过大或死循环，没有足够内存空间OOM

- 运行时常量溢出和元数据溢出，理论山元数据与内存挂钩，也可以修改参数-xx permsize -xx MaxpermSize
溢出情况例如大量生产动态类class的应用。
  
- JStat：显示虚拟机详细参数，加载的类，内存，gc等相关信息
- JStack：虚拟机当前线程快照
- Jps：所有虚拟即进程
  

####7.反射
通过类的全限名得到类的全部信息（典型RPC框架）
class.forName，类目.class，对象.getClass()

